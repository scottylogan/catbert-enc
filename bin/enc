#! /usr/bin/env node

var yaml            = require('js-yaml'),
    fs              = require('fs'),
    progName        = process.argv[1].replace(/^.*\//, ''),
    nodeName        = process.argv[2],
    finalHandlers   = {
      enc: encHandler,
      autosign: autosignHandler,
    },
    configDir,
    classify;


function log(message) {
  fs.appendFileSync('/tmp/enc.log', (new Date()).toISOString() + ' ' + nodeName + ': ' + message + '\n');
}

[ '/etc/enc', '/usr/local/etc/enc', './conf' ].forEach(function (dir) {
  try {
    if (!configDir && fs.statSync(dir).isDirectory()) {
      configDir = dir;
    }
  } catch (e) {
    // ignore
  }

});

try {
  classify = require('enc')(progName, nodeName, configDir, log);
} catch (e) {
  classify = require('../lib/index')(progName, nodeName, configDir, log);
}


function autosignHandler (res) {
  if (res.classes.length === 0) {
    throw new Error('Refusing autosign');
  }
  log('Allowing autosign');
}

function encHandler (res) {
  if (res.classes.length === 0) {
    throw new Error('Not returning classes for ' + nodeName);
  }
  log('Returning classes for ' + nodeName + ': ' + res.classes.join(', '));
  console.log('---\n' + yaml.safeDump(res));
}

try {
  if (process.argv.length !== 3) {
    throw new Error('Expected node name as argument');
  }

  if (!finalHandlers[progName]) {
    throw new Error('Called with unexpected name: ' + progName);
  }

  classify(
    { node: nodeName },
    { environment: 'production', classes: [] },
    function (err, res) {
      if (err) {
        throw new Error('Classification failed: ' + (typeof err === 'string' ? err : err.message));
      } else {
        log('Finished classification');
  
        // already validated handler above
        finalHandlers[progName].call(null, res);
      }
    }
  );

} catch (e) {
  console.error(e.message);
  log(e.message);
  process.exit(1);
}

